description en VHDL pour les différents composants d'une architecture d'un composant effectuant les opérations de rotation pour la commande d'un moteur :

library ieee;
use ieee.std_logic_1164.all;

entity rotate_controller is
    port (
        clk : in std_logic;
        reset : in std_logic;
        rotate_enable : in std_logic;
        rotate_direction : in std_logic;
        rotate_speed : in std_logic_vector(7 downto 0);
        motor_enable : out std_logic;
        motor_direction : out std_logic;
        motor_speed : out std_logic_vector(7 downto 0)
    );
end entity rotate_controller;

architecture behavioral of rotate_controller is
    -- Variables internes
    signal count : unsigned(7 downto 0) := (others => '0');
    signal speed_count : unsigned(7 downto 0) := (others => '0');
    signal enable_count : unsigned(7 downto 0) := (others => '0');

    -- Composants
    component counter is
        port (
            clk : in std_logic;
            reset : in std_logic;
            count : inout unsigned(7 downto 0)
        );
    end component;

    component speed_counter is
        port (
            clk : in std_logic;
            reset : in std_logic;
            speed : in std_logic_vector(7 downto 0);
            speed_count : inout unsigned(7 downto 0)
        );
    end component;

    component enable_counter is
        port (
            clk : in std_logic;
            reset : in std_logic;
            enable_count : inout unsigned(7 downto 0)
        );
    end component;

begin
    -- Compteur pour la rotation
    rotation_counter: counter
        port map (
            clk => clk,
            reset => reset,
            count => count
        );

    -- Compteur pour la vitesse de rotation
    speed_counter: speed_counter
        port map (
            clk => clk,
            reset => reset,
            speed => rotate_speed,
            speed_count => speed_count
        );

    -- Compteur pour l'activation du moteur
    enable_counter: enable_counter
        port map (
            clk => clk,
            reset => reset,
            enable_count => enable_count
        );

    -- Logique de contrôle du moteur
    motor_enable <= '1' when (enable_count > 0) else '0';
    motor_direction <= rotate_direction;
    motor_speed <= rotate_speed;

    -- Logique de contrôle de la rotation
    process(clk, reset)
    begin
        if reset = '1' then
            enable_count <= (others => '0');
        elsif rising_edge(clk) then
            if rotate_enable = '1' then
                enable_count <= enable_count + 1;
            end if;

            if count = 0 then
                count <= 255;
            else
                count <= count - 1;
            end if;
        end if;
    end process;

    -- Logique de contrôle de la vitesse de rotation
    process(clk, reset)
    begin
        if reset = '1' then
            speed_count <= (others => '0');
        elsif rising_edge(clk) then
            if rotate_enable = '1' then
                if speed_count = 0 then
                    count <= count - 1;
                    speed_count <= 255;
                else
                    speed_count <= speed_count - 1;
                end if;
            end if;
        end if;	
    end process;

end architecture behavioral;
